// STATIC: "CONVERT_TO_SRGB" "0..1"	[ps20b][= g_pHardwareConfig->NeedsShaderSRGBConversion()] [PC]
// STATIC: "CONVERT_TO_SRGB" "0..0"	[= 0] [XBOX]

#define HDRTYPE HDR_TYPE_NONE
#include "common_ps_fxc.h"

sampler FBSampler	: register( s0 );
sampler BlurSampler	: register( s1 );

const float g_BrightnessScale : register(c0);
const float g_GreenScale : register(c1);
const float g_BrightFlatness : register(c2);
const float g_DimFlatness : register(c3);

struct PS_INPUT
{
	float2 texCoord				: TEXCOORD0;
};

float4 main( const PS_INPUT i ) : COLOR
{
	float4 vAdd = float4(0.1, 0.1, 0.1, 0); // just a float4 for use later
	
	float4 cColor = tex2D(FBSampler, i.texCoord); //this takes our sampler and turns the rgba into floats between 0 and 1
	cColor += tex2D(FBSampler, i.texCoord.xy + 0.0001); // these 3 lines blur the image slightly
	cColor += tex2D(FBSampler, i.texCoord.xy + 0.0002);
	cColor += tex2D(FBSampler, i.texCoord.xy + 0.0003); 
	
	if (((cColor.r + cColor.g + cColor.b)/3) < 0.9)
	{
		cColor = cColor / g_DimFlatness; //otherwise set it to an average color of the 4 images we just added together
	}
	else
	{
		cColor = cColor / g_BrightFlatness;
	}
	
	float4 cTempColor = cColor; //a new float4 cTempColor for use later
	
	float4 cFinal = cTempColor + vAdd; //adds the floats together
	
	float gHue = (cTempColor.r + cTempColor.g + cTempColor.b) / 3; // sets green the the average of rgb
	float rbHue = gHue / (1 + g_GreenScale);

	cFinal.g = gHue;
	cFinal.r = rbHue;
	cFinal.b = rbHue;
	return cFinal * g_BrightnessScale; // brighten the final image and return it
}
